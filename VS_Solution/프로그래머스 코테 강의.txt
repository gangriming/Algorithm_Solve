프로그래머스 코테 강의

1-1. 해시 문제
- 자료구조(알고리즘)의 선택
- 현 문제는 이름(string)인데, 번호가 주어진다면?
	--> 인덱스로 접근 가능하기때문에 선형 배열로 써도.
- 해시는 key - hash table(value)를 hash function으로 매핑해준다.

1-2. 풀이 예제
- std::map : key로 접근시간이 O(LogN) -> (주로)바이너리 서치 트리
- std::unordered_map : key로 접근시간이 O(1) -> 해시테이블로 구현
- 복잡도 시간도 중요하고, 다른사람들의 솔브를 보면서 좀 깨닫는것도 중요한 것 같다.

=====================

2-1. 탐욕법(Greedy)
- 알고리즘의 각 단계에서, 그 순간에 최적이라고 생각하는것을 선택.
- 현 선택이, 마지막 해담의 최적을 해치지 않아야 한다.

2-2. 풀이 예제
- 단순하게 vector로 for를 돌려도 되지만, 좀 더 자료구조를 활용하면서 한다면 unordered_set, set을 활용할 수 있음
- 1번예제와, 2번예제 다 장단이 있고.. 문제의 제약사향을 잘 읽어보고 O(n)이어도 범위가 작다면 충분히 훌륭하다.

=====================

3-1. 정렬(Sort)
- 소트의 기준을 직접 정해서, 정렬할수만 있으면 ..
- 이 프로그래머스 문제는 정렬 + 그리디 느낌이네.

- 크게 만드는 기준은, 수 길이가 같으면 알아서 잘 하면 되고.
- 대소관계 비교를 위한 기준을 마련해보자..

3-2. 풀이 예제
- 단순하게, to_string과 sort에서의 비교자를 만드는 내용.
- TC를 돌려보고 예외상황도 생각해볼것.

=====================

4-1. 탐욕법(Greedy)
- 앞에서 하나씩 담되, 지금 담으려는것보다 작은것들은 뺸다.
- 탐욕법이 통하는 문제 : 앞단계에서의 선택이, 이후 단계의 동작에 의한 해의 최적에 영향을 주지 않는다. 즉, 앞에서 한 행동은 최선의 행동이다.

4-2.
- string.substr을 이용해서 좀 더 깔끔하고 예쁘게 짤 수 있는 방법 제시.

